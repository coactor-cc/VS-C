<div style="display: flex; justify-content: space-between;">
  <div style="width: 48%;">

## 分治
- devide 
- conquer
- combine
### 凸包问题
• 输入：平面上的n个点的集合Q
• 输出：Q的凸包，CH(Q)
#### Graham-scan
**Graham-scan的基本思想**
- 当沿着凸包逆时针漫游时，总是向左转。
- 在极坐标系下按照极角大小排列，然后逆时针方向漫游点集，去除非Convex hull顶点（非左转点）。
**左转判断（经典计算几何问题）：**
判断向量 \( p_1(x_1, y_1) \) 到 \( p_2(x_2, y_2) \) 是否做左转，只需要判断向量的叉积 \( x_1y_2 - x_2y_1 \) 的正负。如果结果为正，则从 \( p_1 \) 到 \( p_2 \) 做左转。
```
Graham-scan(Q)
/* 栈S从底到顶存储按逆时针方向排列的 CH(Q) 顶点 */
1. 求 Q 中 y-坐标值最小的点 p0;
2. 按照与 p0 极角(逆时针方向)大小排序 Q 中其余点, 结果为 < p1, p2, ..., pn >;
3. Push(p0, S); Push(p1, S); Push(p2, S);
4. for i = 3 to n do
5.     while Next-to-top(S), Top(S) 和 pi 形成非左移动 do
6.         Pop(S);
7.     Push(pi, S);
8. return S;
```
#### 分治求解

### 最大子序列和问题
- 输入：一个整数序列 \( a_1, a_2, ..., a_n \)
- 输出：一个子序列 \( a_i, a_{i+1}, ..., a_j \)，使得该子序列的和最大
#### 动态规划(Kadane算法)
- `currentSum`：表示以当前元素为结束的子数组的最大和。
- `maxSum`：记录全局最大子数组和。
- 转移方程为：
 \[
 \text{currentSum} = \max(\text{currentSum} + \text{nums}[i], \text{nums}[i])
 \]
- 在每一步计算中，比较 `currentSum` 和 `maxSum`，更新全局最大值：
 \[
 \text{maxSum} = \max(\text{maxSum}, \text{currentSum})
 \]
- 时间复杂度：$\Omicron(n)$
- 空间复杂度：$\Omicron(1)$

这个状态转移方程的核心思想是，对于每个元素，我们决定是继续当前子数组的累加还是从当前元素开始一个新的子数组，以保证当前子数组的和是最大的。同时，我们更新全局最大和，以确保在遍历结束后得到整个数组的最大子数组和。
#### 分治
#### 


---
## 网络流
- 有向图理解为一个“流网络”，解决物质流动方面的问题
- 某物质从源点经过一个系统“流”向汇点
- 有向边：限定的容量（物质通过该边的最大速度）
- 每个顶点：“流守恒”
- 问题：不违背容量限制的条件下，物质从源点传输到汇点的最大速率？
- 建模很多实际问题
  - 液体在管道中的流动
  - 装配线上部件的流动
  - 电网中电流的流动、通信网络中信息的流动
### 基础网络流问题
- 输入：有向图 \( G=(V, E) \)，每条边 \( (u, v) \in E \) 有非负容量 \( c(u, v) \)，表示该边所能承载的最大流量，指定一个源点 \( s \) 和汇点 \( t \)
- 输出：找到一个合法的流分配，使 \( s \) 到 \( t \) 的总流量最大，且满足每条边的流量不超过其容量，即 \( \forall(u, v) \in E: 0 \leq f(u, v) \leq c(u, v) \)

### Ford Fulkerson算法
- 迭代地在残存网络找一条从源点到汇点的可行路径（称为增广路径），塞满流量，更新残存网络
- 直到无法找到增广路径为止，最终找到从源点到汇点的最大流
#### 残存网络
**残存网络定义**：给定一个网络 \( G = (V, E) \)，其中 \( V \) 是顶点集，\( E \) 是边集。每条边 \( (u, v) \in E \) 有一个非负的容量 \( c(u, v) \) 和一个当前流量 \( f(u, v) \)。残存网络 \( G_f \) 是基于当前流量 \( f(u, v) \) 构造的。

1. **正向边的残存容量**：对于每条正向边 \( (u, v) \)，其残存容量 \( c_f(u, v) \) 定义为 \( c(u, v) - f(u, v) \)。这表示从 \( u \) 到 \( v \) 方向还可以增加的流量。

2. **反向边的残存容量**：如果 \( f(u, v) > 0 \)，则在残存网络中添加一条反向边 \( (v, u) \)，其残存容量 \( c_f(v, u) \) 定义为 \( f(u, v) \)。这表示可以撤销的流量，即流量可以从 \( v \) 回退到 \( u \)。

### Edmonds-Karp算法
### 最大流最小割定理
#### 网络流的切割
流网络 \( G = (V, E) \) 的源点为 \( s \) 和汇点为 \( t \)，\( G = (V, E) \) 的一个切割 \( (S, T) \) 将点集 \( V \) 划分为两个集合 \( S \) 和 \( T = V - S \)，使得 \( s \in S \)，\( t \in T \)。切割 \( (S, T) \) 的容量是

\[ c(S, T) = \sum_{u \in S} \sum_{v \in T} c(u, v) \]

集合S到T的割线流量
### 最小费用最大流
网络流图attribute不仅有流量，还有cost
#### bellman ford算法
---
## 二部图问题
### 最大二分匹配问题(无向图)
#### 规约为网络流问题
[教程](https://www.bilibili.com/video/BV1G54y157HA/?spm_id_from=333.337.search-card.all.click&vd_source=53f51c0959240fa32634fa6e36d629d5)
#### 匈牙利算法
U、V节点数相同，最初用来解决有权二部图中的最小匹配$\Omicron(n^3)$
### 稳定匹配问题
  </div>
  <div style="width: 48%;">

## 动态规划
如果分解的子问题之间不是相互独立的，分治方法将重复计算公共子问题，效率很低  
自底向上、利用空间换时间
### 动态规划算法的适用范围
- 优化问题：给定一个代价函数，在解空间中搜索具有最小或最大代价的解
- 优化子结构 (Optimal substructure)：当一个问题的最优解包含了子问题的最优解时，我们说这个问题具有优化子结构。
- 重叠子问题 (Subteties)：问题的求解过程中，很多子问题的解将被多次使用
### 矩阵链乘法
• 输入：$<A_1,A_2, ...,A_n>$,$A_i$是$p_{i-1}\times p_i$矩阵 
• 输出：计算$A_1\times A_2\times\cdots\times A_n$的最小代价方法

---
## 贪心
- 优化子问题
- 贪心选择性
###  排队问题
这个问题是一个经典的调度问题，通常称为“最短处理时间优先”（Shortest Processing Time, SPT）问题。目标是找到一种排队顺序，使得所有人的排队时间总和最小。
#### 证明
为了证明这种排序方式是最优的，我们可以使用交换论证法（Exchange Argument）。

假设有一个非最优的排队顺序，即存在两个相邻的人\( i\) 和\( i+1\)，使得\( t_i > t_{i+1}\)。如果我们将这两个人交换位置，那么：
- 第\( i\) 个人的排队时间减少\( t_{i+1}\)。
- 第\( i+1\) 个人的排队时间增加\( t_i\)。

总排队时间的变化为：
\[ (T_i - t_{i+1}) + (T_{i+1} + t_i) - (T_i + T_{i+1}) = t_i - t_{i+1}\]

因为\( t_i > t_{i+1}\)，所以\( t_i - t_{i+1} > 0\)，即交换后总排队时间减少。因此，任何非最优的排队顺序都可以通过交换相邻的逆序对来改善，直到达到最优的排序。
#### 最终答案
按照处理时间\( t_i\) 从小到大的顺序排队，可以使得所有人排队时间总和最小。
\[
\boxed{\text{按照处理时间从小到大的顺序排队}}
\]
### 旅途加油问题
最大化可选择加油站范围
### 任务调度问题
---
## ~~随机算法~~
### 随机数值法
利用统计频率近似概率求解
#### 求解$\pi$
#### 求解定积分 
大数定律：
### Las Vegas
#### 第k小元素问题
• 输入：𝑆={𝑥1,𝑥2,⋯,𝑥𝑛}，整数𝑘，1≤𝑘 ≤𝑛
• 输出：𝑆中第𝑘小元素
#### 算法应用
从n个元素的数组中随机抽取一个元素$x_i$，
建立集合S1，S2, S3 
- 当 \( k \leq |S_1| \) 时，调用 \( Select(S_1, k) \)
- 当 \( |S_1| < k \leq |S_1| + |S_2| \) 时，返回 \( x_i \)
- 当 \( k > |S_1| + |S_2| \) 时，调用 \( Select(S_3, k - |S_1| - |S_2|) \)
### Sherwood
• 消除最坏行为与特定实例的联系
#### 快排引入随机数进行洗牌or随机选取中间值
### 蒙特卡洛
#### 字符串判定相等
抽样判定是否相等 可能会输出错误解。

  </div>
</div>








